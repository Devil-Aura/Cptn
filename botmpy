import re
import logging
import requests
from functools import lru_cache
from botmpy import Bot, Filters

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ===== Configuration =====
class Config:
    BOT_TOKEN = ""
    CHANNEL_USERNAME = "@CrunchyRollChannel"
    DEFAULT_LANGUAGE = "Hindi #Official"
    MAL_CLIENT_ID = "2683e006d6116b8611c50c1dbe20a1a1"
    MAL_CLIENT_SECRET = "124dce382622428e4bf4d9e64fcaeda6745ceb3f86ae8a758fa6c062dfd80be3"
    MAX_RETRIES = 3
    CACHE_SIZE = 100

# ===== MAL API Service =====
class MALService:
    BASE_URL = "https://api.myanimelist.net/v2"
    AUTH_URL = "https://myanimelist.net/v1/oauth2/token"
    
    @classmethod
    @lru_cache(maxsize=1)
    def _get_access_token(cls):
        try:
            response = requests.post(
                cls.AUTH_URL,
                data={
                    'client_id': Config.MAL_CLIENT_ID,
                    'client_secret': Config.MAL_CLIENT_SECRET,
                    'grant_type': 'client_credentials'
                },
                timeout=10
            )
            return response.json().get('access_token', '')
        except Exception as e:
            logger.error(f"Token fetch failed: {e}")
            return ''

    @classmethod
    def _make_request(cls, endpoint, params=None):
        headers = {
            'Authorization': f'Bearer {cls._get_access_token()}',
            'X-MAL-CLIENT-ID': Config.MAL_CLIENT_ID
        }
        try:
            response = requests.get(
                f"{cls.BASE_URL}/{endpoint}",
                headers=headers,
                params=params,
                timeout=10
            )
            response.raise_for_status()
            return response.json()
        except Exception as e:
            logger.error(f"MAL API Error: {e}")
            return None

    @classmethod
    @lru_cache(maxsize=Config.CACHE_SIZE)
    def get_anime_info(cls, query):
        data = cls._make_request(
            "anime",
            params={'q': query, 'limit': 1, 'fields': 'title,alternative_titles'}
        )
        if data and data.get('data'):
            anime = data['data'][0]['node']
            return anime.get('title') or anime.get('alternative_titles', {}).get('en')
        return query

# ===== Jikan Fallback Service =====
class JikanService:
    BASE_URL = "https://api.jikan.moe/v4"
    
    @classmethod
    @lru_cache(maxsize=Config.CACHE_SIZE)
    def get_anime_info(cls, query):
        try:
            response = requests.get(
                f"{cls.BASE_URL}/anime",
                params={'q': query, 'limit': 1},
                timeout=10
            )
            data = response.json()
            if data.get('data'):
                anime = data['data'][0]
                return anime.get('title') or anime.get('titles', [{}])[0].get('title')
            return query
        except Exception as e:
            logger.error(f"Jikan Error: {e}")
            return query

# ===== Filename Parser =====
class FilenameParser:
    @staticmethod
    def parse(filename):
        try:
            # Clean filename
            clean_name = re.sub(r'\.[^.]*$', '', filename)  # Remove extension
            clean_name = re.sub(r'\[@\w+\]', '', clean_name)  # Remove [@channel]
            clean_name = re.sub(r'[_\[\]()]', ' ', clean_name)  # Replace special chars
            clean_name = re.sub(r'\s+', ' ', clean_name).strip()
            
            # Extract quality
            quality_match = re.search(
                r'(\d{3,4}p|HD|FHD|WEB[- ]?DL|BluRay|HEVC|10bit|x26[45]|H\.26[45])',
                clean_name, 
                re.I
            )
            quality = quality_match.group(1) if quality_match else "Unknown"
            
            # Extract season/episode
            ep_match = re.search(
                r'(S|Season\s*)(\d+)\s*(E|Episode\s*|EP\s*|-\s*)(\d+)', 
                clean_name, 
                re.I
            ) or re.search(r'(\d+)x(\d+)', clean_name)
            
            if ep_match:
                season = ep_match.group(2) if len(ep_match.groups()) > 1 else "01"
                episode = ep_match.group(4) if len(ep_match.groups()) > 3 else ep_match.group(2)
                anime_name = clean_name[:ep_match.start()].strip()
            else:
                season = episode = "01"
                anime_name = clean_name
            
            # Clean anime name
            anime_name = re.sub(
                r'\b(480p|720p|1080p|HD|WEB[- ]?DL|BluRay|HEVC|10bit|x26[45])\b', 
                '', 
                anime_name, 
                flags=re.I
            ).strip()
            
            return {
                'anime_name': anime_name,
                'season': season.zfill(2),
                'episode': episode.zfill(2),
                'quality': quality
            }
        except Exception as e:
            logger.error(f"Parse error: {e}")
            return None

# ===== Caption Generator =====
class CaptionGenerator:
    @staticmethod
    def generate(metadata):
        return f"""<b>âž¥ {metadata['anime_name']} [S{metadata['season']}]</b>
<b>ðŸŽ¬ Episode - {metadata['episode']}</b>
<b>ðŸŽ§ Language - {Config.DEFAULT_LANGUAGE}</b>
<b>ðŸ”Ž Quality : {metadata['quality']}</b>
<b>ðŸ“¡ Powered by :</b>
<b>{Config.CHANNEL_USERNAME}</b>"""

# ===== Telegram Bot =====
class AnimeCaptionBot(Bot):
    def __init__(self):
        super().__init__(Config.BOT_TOKEN)
        self.add_handler(
            Filters.channel & (Filters.video | Filters.document),
            self.handle_media
        )
    
    async def handle_media(self, update, context):
        try:
            message = update.channel_post
            media = message.video or message.document
            if not media or not media.file_name:
                return
            
            logger.info(f"Processing: {media.file_name}")
            
            # Parse metadata
            metadata = FilenameParser.parse(media.file_name)
            if not metadata:
                return
            
            # Get verified anime name (with fallback)
            for attempt in range(Config.MAX_RETRIES):
                try:
                    metadata['anime_name'] = MALService.get_anime_info(metadata['anime_name']) or \
                                            JikanService.get_anime_info(metadata['anime_name'])
                    break
                except Exception as e:
                    if attempt == Config.MAX_RETRIES - 1:
                        logger.error(f"Failed after {Config.MAX_RETRIES} attempts: {e}")
            
            # Generate caption
            caption = CaptionGenerator.generate(metadata)
            
            # Edit message
            await context.bot.edit_message_caption(
                chat_id=message.chat.id,
                message_id=message.message_id,
                caption=caption,
                parse_mode='HTML'
            )
            logger.info("Caption updated successfully")
            
        except Exception as e:
            logger.error(f"Handler error: {e}")

# ===== Main Execution =====
if __name__ == '__main__':
    bot = AnimeCaptionBot()
    bot.run()
